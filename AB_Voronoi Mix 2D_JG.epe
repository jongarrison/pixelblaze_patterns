{
  "name": "AB_Voronoi Mix 2D_JG",
  "id": "A9FpA73aQpXTAFAkf",
  "sources": {
    "main": "/*\n Animated Voronoi diagram \n Moves several points around a 2D display, coloring each pixel\n on the display according to the nearest point, with \"nearest\"\n determined by one of a set of user-selectable methods via the\n \"distance method\" and \"drawing mode\" sliders.\n \n *** Yet Another Very Computationally Expensive Pattern! ***\n \n On large displays, be prepared to turn the number of points WAY down, and if you're\n using WS2812 LEDs, set the LED type on your pixelblaze to\n \"Buffered (2x rate) WS2812/Neopixel\" to avoid running out of time during frame \n generation.\n\n Version  Author        Date        Comment\n 1.0.0    JEM(ZRanger1) 12/31/2020  MIT License\n*/ \n\n// array of pointers to distance calculating functions\nvar numModes = 6;\nvar distance = array(numModes);\n\n// Distance methods - each uses a different algorithm for calculating distance\n// Comments in the actual functions explain how each method works.\n// Here are details on the draw modes I think work best w/each method.\ndistance[0] = euclidean;    // all modes are good, but I like 3 and 5\ndistance[1] = wavedistance; // try draw modes 1 and 6\ndistance[2] = deviation;    // try draw modes 2 and 5\ndistance[3] = chebyshev;    // draw modes 4 & 5 are interesting\ndistance[4] = eggcrate;     // recommend draw mode 4\ndistance[5] = manhattan;    // recommend draw mode 2\n\n// array of pointers to pixel drawing functions with varying levels\n// of color and brightness manipulation.  Note that not all \n// drawing modes work well with all distance calculators.\n// Experiment!!\nvar numRenderers = 6;\nvar gamma = array(numRenderers)\n\ngamma[0] = original;   // \"plain\" renderer\ngamma[1] = originalG;  // plain color + gamma correction\ngamma[2] = crispyC;    // enhanced color only\ngamma[3] = crispyCI;   // color + inverted brightness\ngamma[4] = crispyCG;   // color + gamma correction\ngamma[5] = crispyCIG;  // color + inverted bri + gamma\n\n// array of vectors for each point\nvar maxPoints = 8;\nvar Points = array(maxPoints);\n\n// current settings\nexport var numPoints = 5;\nexport var speed = 0.075;\nexport var drawMode = 0;\nexport var distMethod = 0;\n\n// UI\nexport function sliderNumberOfPoints(v) {\n  numPoints = floor(1 + (v * (maxPoints - 1)));\n}\n\nexport function sliderDistanceMethod(v) {\n  distMethod = floor((numModes-1) * v);\n}\n\nexport function sliderDrawingMode(v) {\n  drawMode = floor((numRenderers-1) * v);  \n}\n\nexport function sliderSpeed(v) {\n  speed = 0.15 * v;\n  initPoints();\n}\n\n// create vector with a random position, direction, speed and color. \nfunction initPoints() {\n\n// point/region colors are spaced at equal intervals around the\n// hsv circle.\n  var h = 0;   \n  \n  for (var i = 0; i < numPoints; i++) {\n    var b = Points[i];  \n    \n    b[0] = random(1);       // x position \n    b[1] = random(1);       // y position\n\n    b[2] = random(speed);   // x velocity\n    b[3] = random(speed);   // y velocity\n\n    b[4] = h + i/numPoints; // hue\n  }\n}\n\n// allocate and initialize point descriptors\nfunction createPoints() {\n  for (var i = 0; i < maxPoints; i++) {  \n    Points[i] = array(5);\n  }\n  \n  initPoints();\n}\n\n// move points, bouncing them off the \"walls\" of the display.\nfunction bounce() {\n  for (var i = 0; i < numPoints; i++) {\n    var b = Points[i];\n    \n// move point according to velocity component of its vector \n    b[0] += b[2];\n    b[1] += b[3];\n\n// bounce off walls by flipping vector element sign when we hit.\n// If we hit a wall, we exit early, trading precision in\n// corners for speed.  We'll catch it in a frame or two anyway\n    if (b[0] < 0) { b[0] = 0; b[2] = -b[2]; continue; } \n    if (b[1] < 0) { b[1] = 0; b[3] = -b[3]; continue; }\n\n    if (b[0] > 1) { b[0] = 1; b[2] = -b[2]; continue; }\n    if (b[1] > 1) { b[1] = 1; b[3] = -b[3]; continue; }\n  }\n}\n\n// straightforward 2D euclidean distance \nfunction euclidean(x,y) {\n    return sqrt((x * x) + (y * y));  \n}\n\n// replacing using wave() treats the xy distance as\n// an angle and effectively returns its sine as the distance.\nfunction wavedistance(x,y) {\n    return wave((x * x) + (y * y));  \n}\n\n// \"chessboard\" distance -- how many moves would it take a king\n// to get from one point to the other?\nfunction chebyshev(x,y) {\n    return max(abs(x),abs(y));  \n}\n\n// distance from mean (0.5238 is calculated mean distance\n// between normalized points for a rectangular matrix)\nfunction deviation(x,y) {\n    return abs(sqrt((x * x)+(y * y)) - 0.52038);  \n}\n\n// manhattan distance -- distance with no diagonals\nfunction manhattan(x,y) {\n    return abs(x+y);\n}\n\n// feed dx & dy into an oddly scaled eggcrate surface generator -- crazy!\nfunction eggcrate(x,y) {\n    return 1-(0.1*(cos(x * PI2) + sin (y * PI2)))\n}\n\n// render hue with fixed sat and bri\nfunction original(d,hue) {\n  hsv(hue,1,1);\n}\n\n// render hue with gamma correction\nfunction originalG(d,hue) {\n  var bri = 1-d; bri = bri*bri*bri;\n  hsv(hue,1,bri)\n}\n\n// render with extra color, but no gamma correction\nfunction crispyC(d,hue) {\n  hsv(hue+d,1,d)\n}\n\n// render with extra color, invert & gamma correct distance\nfunction crispyCI(d,hue) {\n  hsv(hue+d,1,1-d);\n}\n\n// render with extra color, invert & gamma correct distance\nfunction crispyCIG(d,hue) {\n  var bri = 1-d; bri = bri*bri*bri;\n  hsv(hue+d,1,bri);\n}\n\n// render with extra color & gamma correction\nfunction crispyCG(d,hue) {\n  var bri = d * d * d * d;\n  hsv(hue+d,1,bri);\n}\n\n// initialize animated points\ncreatePoints();\n\n// move the points around the display.\nexport function beforeRender(delta) {\n  bounce();\n}\n\n// for every pixel, find the nearest ball by exhaustive search, using\n// the distance measuring method specified by mode.\nexport function render2D(index,x,y) {\n  var minDistance,i,r,h,v;\n  \n  minDistance = 32765;   \n  for (i = 0; i < numPoints; i++) {\n    r = distance[distMethod](Points[i][0] - x,Points[i][1] - y)\n    if (r < minDistance) {\n      h = Points[i][4];\n      minDistance = r;\n    }\n  }\n  \n// draw pixel  \n  gamma[drawMode](minDistance,h);\n}\n"
  },
  "preview": "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"
}