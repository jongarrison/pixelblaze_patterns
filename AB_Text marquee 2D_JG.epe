{
  "name": "AB_Text marquee 2D_JG",
  "id": "k5inLiG7z85F86i3W",
  "sources": {
    "main": "\nexport var timeAdjustment = 1.0\n\nexport function sliderTimeAdjustment(v){\n  v = 1.0 - v\n  //The coefficient of v here can be adjust to achieve different speed effects for each patter\n  timeAdjustment = 1.0 + (1 * v)\n}\n\nexport var hueOverride = 0.4\n\nexport function sliderHueOverride(v) {\n  hueOverride = v\n}\n\nexport var christmasMode = 0.0\n\nexport function sliderChristmasMode(v) {\n  if (v < 0.5) {\n    christmasMode = 0.0\n  } else {\n    christmasMode = 1.0\n  }\n}\n\nexport var debugColPointer = 0\n/*\n  Scrolling text marquee 2D\n  \n  This pattern animates ASCII characters scrolling across an LED matrix.\n  \n    Demo: https://youtu.be/668eQjiqSRQ\n  \n  The default settings work well with the $14 8x8 matrix sold here:\n  \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  Use the mapper to define how the matrix is wired (for example, zig-zag). \n  The 8x8 grid above works with the default \"Matrix\" example on the Mapper tab.\n  \n  With no map and just a 1D strip, you can use this to light paint text:\n  \n    https://photos.app.goo.gl/vU2BQsP6V84Zr6Df7\n  \n  Author: Jeff Vyduna (https://ngnr.org)\n  Bugfixes: Zeb (https://forum.electromage.com/u/zeb)\n*/\n\n// Characters we want to scroll by every second. Try 3 for a matrix, or 30 for\n// persistence-of-vision on a strip.\nvar speed = 1.2 //default: 3 //JG\n\n// Define the message to be scrolled across the display\nvar messageLength = 13\nvar message = array(messageLength) // Exported for setting via webSockets\n\n// // \"  Hello?!?\"\n// message[0] = 32; \n// message[1] = 32;  // Leading spaces\n// message[2] = 72;   // H\n// message[3] = 101;  // e\n// message[4] = 108;  // l \n// message[5] = 108;  // l \n// message[6] = 111;  // o \n// message[7] = 30; \n// message[8] = 33; \n// message[9] = 31 // \"?!?\"\n\n// Joyeux Noël - JG 12/24/2023\n// Turn on christmase mode\n// message[0] = 32;  // space\nmessage[0] = 74;  // J\nmessage[1] = 111; // o\nmessage[2] = 121; // y\nmessage[3] = 101; // e\nmessage[4] = 117; // u\nmessage[5] = 120; // x\nmessage[6] = 32;  // space\nmessage[7] = 78;  // N\nmessage[8] = 111;  // o\nmessage[9] = 127;  // e\nmessage[10] = 108;  // l\nmessage[11] = 33;  // !\nmessage[12] = 32;  // space\n\n/* \n  ASCII Chart\n\n  32      48 0    65 A   74 J    83 S    97  a    106 j    115 s\n  33 !    49 1    66 B   75 K    84 T    98  b    107 k    116 t\n  34 \"    50 2    67 C   76 L    85 U    99  c    108 l    117 u\n  35 #    51 3    68 D   77 M    86 V    100 d    109 m    118 v\n  36 $    52 4    69 E   78 N    87 W    101 e    110 n    119 w\n  37 %    53 5    70 F   79 O    88 X    102 f    111 o    120 x\n  38 &    54 6    71 G   80 P    89 Y    103 g    112 p    121 y\n  39 '    55 7    72 H   81 Q    90 Z    104 h    113 q    122 z\n  40 (    56 8    73 I   82 R            105 i    114 r    \n  41 )    57 9                                   \n  42 *    58 :                   91 [                      123 {\n  43 +    59 ;                   92 \\                      124 |\n  44 ,    60 <                   93 ]                      125 }\n  45 -    61 =                   94 ^                      126 ~\n  46 .    62 >                   95 _                      127 ë //JG for Joyeux Noël\n  47 /    63 ?                   96 `                \n          64 @                                            \n*/\n\n\n// Define the font's character set bitmap. See \"Font Implementation\" below.\nvar charRows = 8 // default: 8 - Rows in a character. 1 array per row.\nvar charCols = 8 // default: 8 - Columns in a character. 1 bit per column.\n\nvar fontCharCount = 128 // Max characters in the font. Must be a multiple of 4.\nvar fontBitmap = array(charRows)\nfor (row = 0; row < charRows; row++) fontBitmap[row] = array(fontCharCount / 4)\n\n// Global 8x8bit array for storing and fetching characters from fontBitmap\nvar character = array(charRows)\n\n// Define the 2D matrix display. If your matrix is different dimentions, change\n// these to match or use a smaller matrixRows to scale your text height to fill.\nvar matrixRows = 8 //default: 8\nvar matrixCols = 8 //default: 8\nvar renderBuffer = array(matrixRows)\nfor (row = 0; row < matrixRows; row++) renderBuffer[row] = array(matrixCols)\n\nvar timer = 0 // Accumulates the ms between each beforeRender()\n\n// Calculate the ms between each left shift of the message across matrix columns\nvar colShiftPeriod = (1000 * timeAdjustment) / speed / charCols\n\nexport function beforeRender(delta) {\n  hue = hueOverride\n  colShiftPeriod = (1000 * timeAdjustment) / speed / charCols\n  \n  timer += delta\n  if (timer > colShiftPeriod) { \n    timer -= colShiftPeriod\n    loadNextCol() // Shift and load a new column every colShiftPeriod ms\n  }\n}\n\nexport var hue, sat     // Exported so you can set them over websockets\n//default: hue = 0.05; sat = 0.9   // warm white\n//hue = 0.05; sat = 0.9   // warm white\nhue = 0.3; sat = 0.9   // warm white\n\nexport function render2D(index, x, y) {\n  // y is in world units of 0...1 where (0,0) is the top-left and y is +↓\n  row = floor(y * matrixRows)\n\n  // The column to render is like the row, but physical column 0 (the leftmost)\n  // starts bufferPointer columns into the renderBuffer.\n  col = (floor(x * matrixCols) + bufferPointer) % matrixCols\n  \n  v = renderBuffer[row][col]  // 1 or 0\n  //hsv(hue, sat, v)\n  hsv24(hue, sat, v)\n  //hsv24 //JG - seems to reduce flickr in the ws2812 leds\n}\n\n// On a strip, render the leftmost column. You can use this to light paint in\n// long exposure photographs, or render text in POV projects\nexport function render(index) {\n  // Flip such that pixel 0, usually the closest to power, is the bottom of text\n  index = pixelCount - index - 1\n  \n  // Mode 1: Use entire strip as a full character line height.\n  // row = floor(charRows * index/ pixelCount)\n  \n  // Mode 2: repeat the characters vertically, with linespacing\n  // If you flicker your eyes left-right, you can see the characters.\n  // Looks best if you set `speed` above to much faster, like 30 chars/sec\n  row = index % floor(1.5 * charRows) // 0.5em lineSpacing\n  if (row > charRows - 1) { hsv(0, 0, 0); return } // blank rows\n\n  // Render column 0, which starts bufferPointer columns into the renderBuffer\n  col = bufferPointer % matrixCols\n  \n  // The color is added for light painting rainbows, and so that it's still\n  // somewhat interesting on strips / the default sequencer\n  hue = wave(time(0.02)) - index / pixelCount\n  \n  hsv(hue, sat, renderBuffer[row][col])\n}\n\n\n// When we render the renderBuffer, we start by loading the leftmost column of\n// the matrix from the `bufferPointer` column in the renderBuffer.\nvar bufferPointer = 0 \n\n/*\n  E.g.: 8x8 matrix, rendering halfway through \"AC\": Right side of A, left of C\n\n          renderbuffer[r][c]             Renders as:\n\n  `bufferPointer` == 4 means leftmost column is here, and wraps around to 3\n                     ↓       \n       col = 0 1 2 3 4 5 6 7                0 1 2 3 4 5 6 7\n    row = 0  . . . 1 1 . . .             0  1 . . . . . . 1  \n          1  . . 1 1 1 1 . .             1  1 1 . . . . 1 1  \n          2  . 1 1 . . 1 1 .             2  . 1 1 . . 1 1 .  \n          3  . 1 1 . . 1 1 .             3  . 1 1 . . 1 1 .  \n          4  . 1 1 . 1 1 1 .             4  1 1 1 . . 1 1 .  \n          4  . . 1 1 . 1 1 .             4  . 1 1 . . . 1 1  \n          5  . . . 1 . 1 1 .             5  . 1 1 . . . . 1  \n          7  . . . . . . . .             7  . . . . . . . .  \n                     ↑\n                     This column will be replaced with the next column of \"C\",\n                       ↑ then we'll advance `bufferPointer`\n                     \nEach element is a 16.16 fixed point number, so you could decide to pack HSV or \nRGB info into each byte, but this example is monochrome so each element just \nstores a 0 or 1, making rendering as simple as:\n\n    if (renderBuffer[row][col]) hsv(0,0,1)\n*/\n\nvar messageCols = messageLength * charCols // e.g., 12 chars have 96 columns\nvar messageColPointer = 0 // The next column of the overall message to load\n\n// Load the next column from `message` into `renderBuffer` at `bufferPointer`\nfunction loadNextCol() {\n  charIndex = message[floor(messageColPointer / charCols)]\n  fetchCharacter(charIndex) // loads global `character` with ASCII charIndex\n  \n  colIndex = messageColPointer % charCols\n  for (row = 0; row < charRows; row++) {\n    bit = (((character[row] << colIndex) & 0b10000000) == 0b10000000)\n    renderBuffer[row][bufferPointer] = bit\n  }\n  \n  bufferPointer = (bufferPointer + 1) % matrixCols\n  messageColPointer = (messageColPointer + 1) % messageCols\n  \n  //Jg Alternate Between Red and Green for Christmas Mode\n  debugColPointer = messageColPointer\n  if (christmasMode > 0.5) {\n    if (messageColPointer == 0) {\n      //We toggle the hue\n      if (hueOverride < 0.01) {\n        hueOverride = 0.34\n      } else {\n        hueOverride = 0.0\n      }\n    }\n  }\n    \n}\n\n/*\n  Font Implementation\n  \n  Pixelblaze currently supports up to 64 arrays with 2048 array elements.\n  \n  To store a character set of 8x8 bit characters, we use 8 arrays, \n  one for each row.\n  \n  Four 8-bit maps are packed into each 32 bit array element. This makes the\n  bitwise code a little hard to follow, but uses memory efficiently. The 8 most\n  significant bits are referred to as \"bank 0\"; the next eight bits just left of\n  the binary point are \"bank 1\", etc.\n  \n  Here's the scheme used to store the font bitmap. A period is a zero.\n  \n    ASCII character  A        B        C        D        E\n        `charIndex`  65       66       67       68       69\n      array element  [16]     [16]     [16]     [16]     [17]\n               bank  0        1        2        3        0      \n      fontBitmap[0]  ..11.... 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[1]  .1111... .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[2]  11..11.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[3]  11..11.. .11111.. 11...... .11..11. .1111...\n      fontBitmap[4]  111111.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[5]  11..11.. .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[6]  11..11.. 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[7]  ........ ........ ........ ........ ........\n  \n  charIndex 0..31 (traditionally the ASCII control characters) are left \n  blank for user-defined custom characters.\n*/\n\n/*\n  Font and character functions\n\n  The storeCharacter functions take the character index (< `fontCharCount`) and \n  8 rows of 8 bits. Each row is a byte representing 8 bits of on/off bitmap data\n  to become the pixels of a character. Therefore, this implementation is \n  currently tightly coupled to 8-bit wide characters.\n*/\n\n/*\n  At character index `charIndex`, store 8 bytes of row data specified as \n  sequential arguments r0-r7. This allows us to easily use the public domain \n  font specified as comma-delimited hex bytes at:\n  \n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\nfunction storeCharacter(charIndex, r0, r1, r2, r3, r4, r5, r6, r7) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  packByte(0, element, bank, r0)\n  packByte(1, element, bank, r1)\n  packByte(2, element, bank, r2)\n  packByte(3, element, bank, r3)\n  packByte(4, element, bank, r4)\n  packByte(5, element, bank, r5)\n  packByte(6, element, bank, r6)\n  packByte(7, element, bank, r7)\n}\n\n/*\n  This alternate style stores the character using the 8 row global array named \n  `character`. It could be useful for storing sprites after transformations to\n  create animations.\n*/\nfunction storeCharacter2(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    packByte(row, element, bank, character[row])\n  }\n}\n\n// Loads the global `character` from the specified charIndex\nfunction fetchCharacter(charIndex) {\n  element = floor(charIndex / 4)\n  bank = charIndex % 4\n  for (var row = 0; row < charRows; row++) {\n    character[row] = unpackByte(row, element, bank)\n  }\n}\n\n/*\n  For a given row of a font's pixel data (fontBitmap[row]), there's a \n  (fontCharCount / 4) element long array that holds 32 bits per array element. \n  Thinking of each array element as a 4-byte word, the \"bank\" (0..3) specifies \n  which set of 8 bits we're storing for a particular character. Characters are \n  referred to by their charIndex (ASCII number), so:\n  bank 0 in elements 0, 1, & 2 store the data for characters 0, 4, 8, etc;\n  Bank 1 in elements 0, 1, & 2 store the data for characters 1, 5, 9, etc.\n  \n  The method below is used because the bitwise operators only work on \n  the top 16 bits.\n*/\nvar byteHolder = array(4)\nfunction packByte(row, element, bank, byte) {\n  original = fontBitmap[row][element]\n  \n  // Load a 4-element array with the individual bytes in this 32 bit 'word'\n  for (_bank = 0; _bank < 4; _bank++) {\n    byteHolder[_bank] = (((original << (_bank * 8)) & 0xFF00) >> 8) & 0xFF\n  }\n  \n  // Override the 8 bits we're trying to store\n  byteHolder[bank] = byte \n  \n  // Reassemble the 32 bit 'word'\n  fontBitmap[row][element] = (byteHolder[0] << 8) \n                            + byteHolder[1] \n                           + (byteHolder[2] >> 8) \n                           + (byteHolder[3] >> 16)\n}\n\n// Inverse of packByte()\nfunction unpackByte(row, element, bank) {\n  word = fontBitmap[row][element]\n  if (bank > 1) {\n    byte = word << (8 * (bank - 1))\n  } else if (bank == 0) {\n    byte = word >> 8\n  } else {\n    byte = word\n  }\n  return byte & 0xFF // Zero out all but the 8 bits left of the binary point\n}\n\n\n\n/* \n  Font Data\n\n  Public domain, courtesy of\n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\n\nstoreCharacter( 32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x20 (space)\nstoreCharacter( 33, 0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00)  // 0x21 (exclam)\nstoreCharacter( 34, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x22 (quotedbl)\nstoreCharacter( 35, 0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00)  // 0x23 (numbersign)\nstoreCharacter( 36, 0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00)  // 0x24 (dollar)\nstoreCharacter( 37, 0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00)  // 0x25 (percent)\nstoreCharacter( 38, 0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00)  // 0x26 (ampersand)\nstoreCharacter( 39, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x27 (quotesingle)\nstoreCharacter( 40, 0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00)  // 0x28 (parenleft)\nstoreCharacter( 41, 0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00)  // 0x29 (parenright)\nstoreCharacter( 42, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00)  // 0x2a (asterisk)\nstoreCharacter( 43, 0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00)  // 0x2b (plus)\nstoreCharacter( 44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60)  // 0x2c (comma)\nstoreCharacter( 45, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00)  // 0x2d (hyphen)\nstoreCharacter( 46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x2e (period)\nstoreCharacter( 47, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00)  // 0x2f (slash)\nstoreCharacter( 48, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00)  // 0x30 (zero)\nstoreCharacter( 49, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00)  // 0x31 (one)\nstoreCharacter( 50, 0x78, 0xcc, 0x0c, 0x38, 0x60, 0xc4, 0xfc, 0x00)  // 0x32 (two)\nstoreCharacter( 51, 0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00)  // 0x33 (three)\nstoreCharacter( 52, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00)  // 0x34 (four)\nstoreCharacter( 53, 0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00)  // 0x35 (five)\nstoreCharacter( 54, 0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00)  // 0x36 (six)\nstoreCharacter( 55, 0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00)  // 0x37 (seven)\nstoreCharacter( 56, 0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00)  // 0x38 (eight)\nstoreCharacter( 57, 0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00)  // 0x39 (nine)\nstoreCharacter( 58, 0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00)  // 0x3a (colon)\nstoreCharacter( 59, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0x00)  // 0x3b (semicolon)\nstoreCharacter( 60, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00)  // 0x3c (less)\nstoreCharacter( 61, 0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00)  // 0x3d (equal)\nstoreCharacter( 62, 0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00)  // 0x3e (greater)\nstoreCharacter( 63, 0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00)  // 0x3f (question)\nstoreCharacter( 64, 0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00)  // 0x40 (at)\nstoreCharacter( 65, 0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00)  // 0x41 (A)\nstoreCharacter( 66, 0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00)  // 0x42 (B)\nstoreCharacter( 67, 0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00)  // 0x43 (C)\nstoreCharacter( 68, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00)  // 0x44 (D)\nstoreCharacter( 69, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00)  // 0x45 (E)\nstoreCharacter( 70, 0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00)  // 0x46 (F)\nstoreCharacter( 71, 0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00)  // 0x47 (G)\nstoreCharacter( 72, 0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x48 (H)\nstoreCharacter( 73, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x49 (I)\nstoreCharacter( 74, 0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00)  // 0x4a (J)\nstoreCharacter( 75, 0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00)  // 0x4b (K)\nstoreCharacter( 76, 0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00)  // 0x4c (L)\nstoreCharacter( 77, 0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00)  // 0x4d (M)\nstoreCharacter( 78, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00)  // 0x4e (N)\nstoreCharacter( 79, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00)  // 0x4f (O)\nstoreCharacter( 80, 0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00)  // 0x50 (P)\nstoreCharacter( 81, 0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00)  // 0x51 (Q)\nstoreCharacter( 82, 0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00)  // 0x52 (R)\nstoreCharacter( 83, 0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00)  // 0x53 (S)\nstoreCharacter( 84, 0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x54 (T)\nstoreCharacter( 85, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00)  // 0x55 (U)\nstoreCharacter( 86, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x56 (V)\nstoreCharacter( 87, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00)  // 0x57 (W)\nstoreCharacter( 88, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00)  // 0x58 (X)\nstoreCharacter( 89, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00)  // 0x59 (Y)\nstoreCharacter( 90, 0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00)  // 0x5a (Z)\nstoreCharacter( 91, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00)  // 0x5b (bracketleft)\nstoreCharacter( 92, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00)  // 0x5c (backslash)\nstoreCharacter( 93, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00)  // 0x5d (bracketright)\nstoreCharacter( 94, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00)  // 0x5e (asciicircum)\nstoreCharacter( 95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff)  // 0x5f (underscore)\nstoreCharacter( 96, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x60 (grave)\nstoreCharacter( 97, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00)  // 0x61 (a)\nstoreCharacter( 98, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00)  // 0x62 (b)\nstoreCharacter( 99, 0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00)  // 0x63 (c)\nstoreCharacter(100, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00)  // 0x64 (d)\nstoreCharacter(101, 0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00)  // 0x65 (e)\nstoreCharacter(102, 0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00)  // 0x66 (f)\nstoreCharacter(103, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x67 (g)\nstoreCharacter(104, 0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00)  // 0x68 (h)\nstoreCharacter(105, 0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x69 (i)\nstoreCharacter(106, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78)  // 0x6a (j)\nstoreCharacter(107, 0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00)  // 0x6b (k)\nstoreCharacter(108, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00)  // 0x6c (l)\nstoreCharacter(109, 0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00)  // 0x6d (m)\nstoreCharacter(110, 0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00)  // 0x6e (n)\nstoreCharacter(111, 0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00)  // 0x6f (o)\nstoreCharacter(112, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0)  // 0x70 (p)\nstoreCharacter(113, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e)  // 0x71 (q)\nstoreCharacter(114, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00)  // 0x72 (r)\nstoreCharacter(115, 0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00)  // 0x73 (s)\nstoreCharacter(116, 0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00)  // 0x74 (t)\nstoreCharacter(117, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00)  // 0x75 (u)\nstoreCharacter(118, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00)  // 0x76 (v)\nstoreCharacter(119, 0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00)  // 0x77 (w)\nstoreCharacter(120, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00)  // 0x78 (x)\nstoreCharacter(121, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8)  // 0x79 (y)\nstoreCharacter(122, 0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00)  // 0x7a (z)\nstoreCharacter(123, 0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00)  // 0x7b (braceleft)\nstoreCharacter(124, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00)  // 0x7c (bar)\nstoreCharacter(125, 0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00)  // 0x7d (braceright)\nstoreCharacter(126, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)  // 0x7e (asciitilde)\n\n\n// Other user-defined custom characters\n\n// ASCII 63 is the question mark - here's an alternative from the \n// Sinclair ZX81 font, stored in custom slot 30\nstoreCharacter(30,\n  0b00000000,\n  0b00111100,\n  0b01000010,\n  0b00000100,\n  0b00001000,\n  0b00000000,\n  0b00001000,\n  0b00000000\n)\n\n//JG - Attempt at an e with umlauts for Joyeux Noel!\nstoreCharacter(127,\n  0b00100100,\n  0b00000000,\n  0b00111100,\n  0b01100110,\n  0b01111110,\n  0b01100000,\n  0b00111100,\n  0b00000000\n)\n\n//JG - Overriding ! to be skinnier, Customer Request!\nstoreCharacter(33,\n  0b01000000,\n  0b01000000,\n  0b01000000,\n  0b01000000,\n  0b01000000,\n  0b00000000,\n  0b01000000,\n  0b00000000\n)\n\n// This demonstrates copying the character, altering it, then storing it in the \n// next slot. You could use this for programmatic animation.\nfetchCharacter(30)\ncharacter[7] = 0b00001000\nstoreCharacter2(31)\n"
  },
  "preview": "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"
}